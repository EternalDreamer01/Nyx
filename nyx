#!/usr/bin/env node

require('dotenv').config({ path: __dirname + '/.env' })

const { Api: TelegramApi, TelegramClient, Logger: TelegramLogger } = require("telegram");
const { StringSession } = require("telegram/sessions/index.js");
const input = require("input");
const WhatsApp = require("whatsapp-web.js");
const QRCcode = require("qrcode-terminal");
const fs = require('fs');
const request = require('request');

require('yargs').help(false);
const { argv } = require('yargs');


const Telegram = {
	photo: {
		get: async function (client, userList) {
			for (let i = 0; i < userList.length && i < 10; ++i) {
				userList[i].photo = await client.downloadProfilePhoto(userList[i].id, {
					isBig: true
				});
			}
			return userList;
		},
		isAvailable: (buf) => {
			if (Buffer.isBuffer(buf))
				return buf.byteLength !== 0;
			else if (typeof buf === "string")
				return buf.length !== 0;

			return false;
		}
	}
}

const download = (url, dest, cb) => {
	const file = fs.createWriteStream(dest);
	const sendReq = request.get(url);

	// verify response code
	sendReq.on('response', (response) => {
		if (response.statusCode !== 200) {
			return cb('Response status was ' + response.statusCode);
		}

		sendReq.pipe(file);
	});

	// close() is async, call cb after close completes
	file.on('finish', () => file.close(cb));

	// check for request errors
	sendReq.on('error', (err) => {
		fs.unlink(dest, () => cb(err)); // delete the (partial) file and then return the error
	});

	file.on('error', (err) => { // Handle errors
		fs.unlink(dest, () => cb(err)); // delete the (partial) file and then return the error
	});
};

const { API_TELEGRAM_TOKEN, API_TELEGRAM_ID, API_TELEGRAM_HASH, DEFAULT_INFO_FORMAT, HOME } = process.env;

const prog = process.argv[1].split(/\\|\//).pop();

argv.colour = argv.colour !== false;
const colour = (...args) => !argv.colour ? "" : "\x1b[" + args.join(";") + "m";

// http://patorjk.com/software/taag/#p=display&f=Fraktur&t=nyx
const logo = `                                        ..                      
                           u.    u.    @L             uL   ..   
                         x@88k u@88c. 9888i   .dL   .@88b  @88R 
                        ^"8888""8888" \`Y888k:*888. '"Y888k/"*P  
                          8888  888R    888E  888I    Y888L     
                          8888  888R    888E  888I     8888     
                          8888  888R    888E  888I     \`888N    
                          8888  888R    888E  888I  .u./"888&   
                         "*88*" 8888"  x888N><888' d888" Y888*" 
                           ""   'Y"     "88"  888  \` "Y   Y"    
${colour("4")}Usage:${colour("0")} ${colour("36")}${prog}${colour("0")} ${colour("1")}phone${colour("0")}                              88F               
                                             98"                
  ${colour("1")}phone${colour("0")}           International format     ./"                  
                                          ~\``

var WhatsAppClient = null;
async function main() {
	try {
		if (process.argv.length < 3 || argv._.length === 0 || argv.h || argv.help || argv["?"]) {
			console.log(`${logo}
  -p --photo      Download photo
  -s --save       Save all user data (implies photo) into '${HOME}/${prog}'
  -f --format=FMT Define output format (default: ${colour("1")}${DEFAULT_INFO_FORMAT || "text"}${colour("0")})
                  Available formats: 'text', 'json'
  --no-colour     No colour (only usable in 'text' format for stdout)

  -h  --help      Show this help`)
			return 0;
		}
		const phone = typeof argv._[0] === "string" ? argv._[0].replace(/ |-|\\|\/|\.|^(\+*)(0*)/g, '') : argv._[0] + "";
		const pathToken = `${HOME}/.local/share/${prog}/auth`;
		const pathCache = `${HOME}/.local/share/${prog}/cache`;
		const pathPhone = `${HOME}/${prog}/${phone}`;
		// fs.mkdirSync(pathToken, { recursive: true });
		if (argv.s)
			argv.save = true;
		if (argv.save !== false || argv.p || argv.photo) {
			argv.photo = true;
			fs.mkdirSync(pathPhone, { recursive: true });
		}

		const format = (() => {
			if (typeof argv.format === "string")
				return argv.format.toLowerCase();
			if (typeof argv.f === "string")
				return argv.f.toLowerCase();
			return !DEFAULT_INFO_FORMAT || DEFAULT_INFO_FORMAT === "text" ? "text" : "json";
		})();

		const dataJson = {
			whatsapp: undefined,
			telegram: undefined
		};
		let dataText = "";

		const printText = text => {
			console.log(text);
			dataText += text.replace(/\x1b[[0-9;]+m/g, "") + "\n";
		}

		// console.log(pathToken);

		{
			const user = await new Promise(resolve => {
				WhatsAppClient = new WhatsApp.Client({
					authStrategy: new WhatsApp.LocalAuth({ dataPath: pathToken }),
					puppeteer: {
						// handleSIGINT: false,
						// headless: true,
						args: [
							"--no-sandbox",
							"--disable-setuid-sandbox",
							"--disable-extensions",
							'--disable-gpu',
							"--disable-accelerated-2d-canvas",
							"--no-first-run",
							"--no-zygote",
							"--disable-dev-shm-usage"
						],
						// takeoverOnConflict: true,
					},
					webVersionCache: {
						type: "local",
						localPath: pathCache
					},
					qrMaxRetries: 2
				});

				WhatsAppClient.on('qr', qr => {
					console.log("To login to WhatsApp, scan the following QRCode within WhatsApp settings");
					QRCcode.generate(qr, { small: true });
				});
				WhatsAppClient.on('authenticated', qr => {
					// console.log("Authenticated");
				});
				WhatsAppClient.on('ready', async () => {
					try {
						resolve(await WhatsAppClient.getContactById(phone + "@c.us"));
					}
					catch (e) {
						console.error(e);
						resolve(null);
					}
				});
				WhatsAppClient.initialize();
			})
			if (user !== null) {
				const [picture, number, about, chat] = await Promise.all([
					user.getProfilePicUrl(),
					user.getFormattedNumber(),
					user.getAbout(),
					user.getChat()
				]);
				if (!user.name && !user.pushname && !user.shortName && !picture && !about && typeof chat?.timestamp !== "number")
					printText(`${colour("1;4")}WhatsApp:${colour("0")} ❌ Phone not occupied`);
				else if (format === "text") {
					printText(`${colour("1;4")}WhatsApp:${colour("0")}
  Type:          ${user.isBusiness ? "Business" : user.isUser ? "User" : "Unknown"}

  Name:          ${colour("36")}${user.name || ""}${colour("0")}
  Pushname:      ${colour("36")}${user.pushname || ""}${colour("0")}
  Short name:    ${colour("36")}${user.shortName || ""}${colour("0")}

  Picture:       ${picture || ""}
  Phone:         ${colour("32")}${number || ""}${colour("0")}
  About:         ${colour("33")}${about || ""}${colour("0")}
  Last activity: ${typeof chat?.timestamp === "number" ? colour("35") + new Date(chat.timestamp * 1000) + colour("0") : colour("3") + "Unknown" + colour("0")}
`);
				}
				else {
					dataJson.whatsapp = {
						type: user.isBusiness ? "Business" : user.isUser ? "User" : null,
						name: user.name || "",
						pushname: user.pushname || "",
						shortname: user.shortName || "",
						picture: picture || "",
						phone: number || "",
						about: about || "",
						lastActivity: chat?.timestamp === "number" ? new Date(chat.timestamp * 1000) : null
					}
				}
				if (argv.photo && typeof picture === "string") {
					const res = await new Promise(r => download(picture, `${pathPhone}/whatsapp.${picture.split('?', 2)[0].split('.').pop()}`, r));
					if (res instanceof Error)
						throw res;
				}
			}
			await WhatsAppClient.destroy();
			WhatsAppClient = null;
		}
		{
			const client = new TelegramClient(
				new StringSession(API_TELEGRAM_TOKEN),
				parseInt(API_TELEGRAM_ID),
				API_TELEGRAM_HASH,
				{
					baseLogger: new TelegramLogger("error")
				});

			await client.start({
				phoneNumber: async () => await input.text("Phone number:"),
				password: async () => await input.text("Account password:"),
				phoneCode: async () => await input.text("Received code:"),
				onError: err => undefined /*console.error(err)*/,
			});
			if (!API_TELEGRAM_TOKEN) {
				console.log("Telegram token:", client.session.save());
				console.log("Make sure to save it safely");
			}
			await client.connect();

			try {
				const tg = await client?.invoke(
					new TelegramApi.contacts.ResolvePhone({
						phone
					})
				);
				if (tg !== undefined)
					tg.users = await Telegram.photo.get(client, tg.users);

				if (format === "text") {
					printText(`${colour("1;4")}Telegram:${colour("0")}`);
					const multipleAccount = tg.users.length !== 1;
					const pad = multipleAccount ? "    " : "  ";
					for (let i = 0; i < tg.users.length; ++i) {
						const {
							className,
							id,
							accessHash,
							verified,
							restricted,
							premium,
							storiesHidden,
							botBusiness,
							firstName,
							lastName,
							username,
							phone: phoneNumber,
							photo,
							restrictionReason,
							langCode,
							status
						} = tg.users[i];
						const { wasOnline } = status || { wasOnline: null }

						if (multipleAccount)
							console.log(`  ${colour("4")}${i} - ${username || `${firstName || ""} ${lastName || ""}`.trim()}:${colour("0")}`)
						printText(`${pad}Type:          ${className}
${pad}ID:            ${id}
${pad}Access Hash:   ${accessHash}
${pad}Bot Business:  ${botBusiness}
${pad}Restricted:    ${restricted}
${pad}Restriction Reason: ${restrictionReason || ""}
	
${pad}First name:    ${colour("34")}${firstName || ""}${colour("0")}
${pad}Last name:     ${colour("34")}${lastName || ""}${colour("0")}
${pad}Username:      ${colour("36")}${username || ""}${colour("0")}

${pad}Verified:      ${colour("35")}${verified}${colour("0")}
${pad}Premium:       ${colour("35")}${premium}${colour("0")}
${pad}Picture:       ${colour("35")}${Telegram.photo.isAvailable(photo) ? "Have" : "Do not have"}${colour("0")}
${pad}Phone:         ${colour("32")}${phoneNumber || ""}${colour("0")}
${pad}Language:      ${colour("32")}${langCode || ""}${colour("0")}
${pad}Last activity: ${typeof wasOnline === "number" ? colour("35") + new Date(wasOnline * 1000) + colour("0") : colour("3") + "Unknown" + colour("0")}`);
						if (argv.photo && Telegram.photo.isAvailable(photo))
							fs.writeFileSync(`${pathPhone}/telegram-${i}.jpg`, photo);
					}
				}
				else {
					dataJson.telegram = tg.users.map(user => {
						const {
							className,
							id,
							accessHash,
							verified,
							restricted,
							premium,
							storiesHidden,
							botBusiness,
							firstName,
							lastName,
							username,
							phone: __phone,
							photo,
							restrictionReason,
							langCode,
							status
						} = user;
						const { wasOnline } = status || { wasOnline: null };
						return {
							className,
							id: parseInt(id),
							accessHash: parseInt(accessHash),
							verified,
							restricted,
							premium,
							storiesHidden,
							botBusiness,
							firstName,
							lastName,
							username,
							phone: __phone,
							photo: Telegram.photo.isAvailable(photo),
							restrictionReason,
							lang: langCode,
							lastActivity: new Date(wasOnline * 1000)
						};
					})
				}
			}
			catch (e) {
				if (e?.errorMessage === "PHONE_NOT_OCCUPIED")
					printText(`${colour("1;4")}Telegram:${colour("0")} ❌ Phone not occupied`);
				else
					console.error(e);
			}
		}

		// console.log("${colour("1;32")}Done.${colour("0")}");
		if (format === "json")
			console.log(JSON.stringify(dataJson));
		if (argv.save === true)
			fs.writeFileSync(`${pathPhone}/info.${format === "text" ? "txt" : "json"}`, format === "text" ? dataText : JSON.stringify(dataJson));
		return 0;
	}
	catch (e) {
		console.error(e);
		// if (argv.save === true)
		// 	fs.writeFileSync(`${phone}/info.${format === "text" ? "txt" : "json"}`, format === "text" ? dataText : dataJson);
		return 1;
	}
}
process.on("SIGINT", async () => {
	// console.log("(SIGINT) Shutting down...");
	await WhatsAppClient?.destroy();
	process.exit(1);
})

main()
	.then(status => process.exit(status))
	.catch(() => process.exit(1))